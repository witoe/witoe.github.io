"use strict";(self.webpackChunkblog2=self.webpackChunkblog2||[]).push([[5562],{8022:(e,n,a)=>{a.r(n),a.d(n,{data:()=>s});const s={key:"v-17347146",path:"/python/notes_for_learning_python/4_Functions-and-Generators.html",title:"Functions and Generators",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"Function Basics",slug:"function-basics",children:[]},{level:2,title:"Scopes",slug:"scopes",children:[{level:3,title:"Name Resolution: The LEGB Rule",slug:"name-resolution-the-legb-rule",children:[]},{level:3,title:"The global/nonlocal Statement",slug:"the-global-nonlocal-statement",children:[]}]},{level:2,title:"Arguments",slug:"arguments",children:[]},{level:2,title:"Advanced Function Topics",slug:"advanced-function-topics",children:[{level:3,title:"Function attributes and annotations",slug:"function-attributes-and-annotations",children:[]}]},{level:2,title:"Comprehensions and Generations",slug:"comprehensions-and-generations",children:[]},{level:2,title:"The benchmarking Interlude",slug:"the-benchmarking-interlude",children:[]}],filePathRelative:"python/notes_for_learning_python/4_Functions-and-Generators.md",git:{updatedTime:163774408e4,contributors:[{name:"guyong",email:"jcel@qq.com",commits:1}]}}},2266:(e,n,a)=>{a.r(n),a.d(n,{default:()=>Se});var s=a(6252),l=a(8033);const t=(0,s._)("h1",{id:"functions-and-generators",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#functions-and-generators","aria-hidden":"true"},"#"),(0,s.Uk)(" Functions and Generators")],-1),o=(0,s._)("h2",{id:"function-basics",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#function-basics","aria-hidden":"true"},"#"),(0,s.Uk)(" Function Basics")],-1),i=(0,s._)("ul",null,[(0,s._)("li",null,[(0,s._)("em",null,"def"),(0,s.Uk)(" is executable code. it’s legal (and even occasionally useful) to nest def statements inside if statements, while loops, and even other "),(0,s._)("em",null,"def"),(0,s.Uk)("s.")]),(0,s._)("li",null,[(0,s._)("em",null,"def"),(0,s.Uk)(" creates an object and assigns it to a name. Function objects may also have arbitrary user-defined "),(0,s._)("em",null,"attributes"),(0,s.Uk)(" attached to them to record data.")])],-1),r=(0,s._)("p",null,[(0,s.Uk)("Names are always looked up in "),(0,s._)("em",null,"scopes"),(0,s.Uk)("—places where variables are stored— and assignments bind names to scopes.")],-1),u=(0,s._)("blockquote",null,[(0,s._)("p",null,"Files must generally be rewound (e.g., with a file.seek(0) or another open) after they have been read to end-of-file once, and so are single-pass iterators")],-1),c=(0,s._)("h2",{id:"scopes",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#scopes","aria-hidden":"true"},"#"),(0,s.Uk)(" Scopes")],-1),d=(0,s._)("p",null,"When we talk about the search for a name’s value in relation to code, the term scope refers to a namespace: that is, the location of a name’s assignment in your source code determines the scope of the name’s visibility to your code.",-1),m=(0,s._)("p",null,"By default, all names assigned inside a function are associated with that function’s namespace, and no other.",-1),h=(0,s._)("p",null,"Lexical scoping:",-1),p=(0,s._)("ul",null,[(0,s._)("li",null,"If a variable is assigned inside a def, it is local to that function."),(0,s._)("li",null,"If a variable is assigned in an enclosing def, it is nonlocal to nested functions."),(0,s._)("li",null,"If a variable is assigned outside all defs, it is global to the entire file.")],-1),b=(0,s._)("p",null,"Each module is a global scope, the global scope spans a single file only.",-1),_=(0,s._)("ul",null,[(0,s._)("li",null,"Assigned names are local unless declared global or nonlocal"),(0,s._)("li",null,"All other names are enclosing function locals, globals, or built-ins."),(0,s._)("li",null,"Each call to a function creates a new local scope.")],-1),f=(0,s._)("blockquote",null,[(0,s._)("p",null,[(0,s.Uk)("Note "),(0,s._)("code",null,"L=X"),(0,s.Uk)(" within a function will classify L as a local, but L.append(X) will not.")])],-1),g=(0,s._)("h3",{id:"name-resolution-the-legb-rule",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#name-resolution-the-legb-rule","aria-hidden":"true"},"#"),(0,s.Uk)(" Name Resolution: The LEGB Rule")],-1),y=(0,s._)("ul",null,[(0,s._)("li",null,"Name assignments create or change local names by default."),(0,s._)("li",null,"Name references search at most four scopes: local, then enclosing functions (if any), then global, then built-in."),(0,s._)("li",null,"Names declared in global and nonlocal statements map assigned names to enclosing module and function scopes, respectively.")],-1),x=(0,s._)("p",null,"Note that the second scope lookup layer, E—the scopes of enclosing defs or lambdas—can technically correspond to more than one lookup level.",-1),v=(0,s._)("p",null,"Also keep in mind that these rules apply only to simple variable names (e.g., spam). Qualified attribute names (e.g., object.spam) live in particular objects and follow a completely different set of lookup rules than those covered here.",-1),k=(0,s._)("p",null,"There are technically three more scopes in Python—temporary loop variables in some comprehensions, exception reference variables in some try handlers, and local scopes in class statements",-1),w=(0,s._)("p",null,"In 3.X, the loop variables are local to the expression itself in all comprehension forms: generator, list, set, and dictionary. In 2.X, they are local to generator expressions and set and dictionary compressions, but not to list comprehensions that map their names to the scope outside the expression. By contrast, for loop statements never localize their variables to the statement block in any Python.",-1),U=(0,s._)("p",null,"In 3.X, exception reference variables are local to that except block, and in fact are removed when the block is exited (even if you’ve used it earlier in your code!).",-1),T=(0,s._)("p",null,"Although the LEGB rule is used to resolve names used in both the top level of a class itself as well as the top level of method functions nested within it, classes themselves are skipped by scope lookups—their names must be fetched as object attributes.",-1),A=(0,s._)("h3",{id:"the-global-nonlocal-statement",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#the-global-nonlocal-statement","aria-hidden":"true"},"#"),(0,s.Uk)(" The global/nonlocal Statement")],-1),X=(0,s._)("p",null,"The global statement consists of the keyword global, followed by one or more names separated by commas. All the listed names will be mapped to the enclosing module’s scope when assigned or referenced within the function body.",-1),I=(0,s._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s._)("pre",{class:"language-text"},[(0,s._)("code",null,"global x\n")]),(0,s._)("div",{class:"line-numbers"},[(0,s._)("span",{class:"line-number"},"1"),(0,s._)("br")])],-1),P=(0,s._)("p",null,"The name x do not need even exist in the enclosing module before the function runs; in this case, the first assignment in the function creates x in the module.",-1),j=(0,s._)("p",null,"If, on the other hand, X is declared nonlocal within the function in 3.X (only), the assignment changes the name X in the closest enclosing function’s local scope. The name X must have been defined in at least one enclosing function.",-1),G=(0,s._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s._)("pre",{class:"language-text"},[(0,s._)("code",null,"def f1():\nx = 88\ndef f2(x=x): # Remember enclosing scope X with defaults\nprint(x)\nf2()\nf1() # Prints 88\n")]),(0,s._)("div",{class:"line-numbers"},[(0,s._)("span",{class:"line-number"},"1"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"2"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"3"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"4"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"5"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"6"),(0,s._)("br")])],-1),B=(0,s._)("p",null,"Because the second x is evaluated before Python steps into the nested def, it still refers to the x in f1.",-1),F=(0,s._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s._)("pre",{class:"language-text"},[(0,s._)("code",null,"def func():\nx = 4\naction = (lambda n, x=x: x ** n) # Pass x in manually\nreturn action\n")]),(0,s._)("div",{class:"line-numbers"},[(0,s._)("span",{class:"line-number"},"1"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"2"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"3"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"4"),(0,s._)("br")])],-1),q=(0,s._)("p",null,"Loop variables may require defaults, not scopes, Compare",-1),L=(0,s._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s._)("pre",{class:"language-text"},[(0,s._)("code",null,">>> def makeActions():\nacts = []\nfor i in range(5): # Tries to remember each i\nacts.append(lambda x: i ** x) # But all remember same last i!\nreturn acts\n")]),(0,s._)("div",{class:"line-numbers"},[(0,s._)("span",{class:"line-number"},"1"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"2"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"3"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"4"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"5"),(0,s._)("br")])],-1),N=(0,s._)("p",null,"with",-1),R=(0,s._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s._)("pre",{class:"language-text"},[(0,s._)("code",null,">>> def makeActions():\nacts = []\nfor i in range(5): # Use defaults instead\nacts.append(lambda x, i=i: i ** x) # Remember current i\nreturn acts\n")]),(0,s._)("div",{class:"line-numbers"},[(0,s._)("span",{class:"line-number"},"1"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"2"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"3"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"4"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"5"),(0,s._)("br")])],-1),S=(0,s._)("p",null,"Because defaults are implemented as single objects attached to functions, mutable defaults retain state from call to call, rather than being initialized anew on each call.",-1),E=(0,s._)("p",null,"Unlike global, nonlocal names must already exist in the enclosing function’s scope when declared. In fact, they are checked at function definition time before either an enclosing or nested function is called.",-1),z=(0,s._)("p",null,"Nonlocal both allows assignment to names in enclosing function scopes and limits scope lookups for such names to enclosing defs.",-1),C=(0,s._)("p",null,"Python uses naming conventions in both 2.X and 3.X that ensure that the arbitrary names you assign as function attributes won’t clash with names related to internal implementation.",-1),D=(0,s._)("p",null,"To summarize: globals, nonlocals, classes, and function attributes all offer changeable state-retention options.",-1),O=(0,s._)("h2",{id:"arguments",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#arguments","aria-hidden":"true"},"#"),(0,s.Uk)(" Arguments")],-1),W=(0,s._)("p",null,"In Python 2.X, it’s also possible to automatically unpack tuples in arguments passed to a function.",-1),Z=(0,s._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s._)("pre",{class:"language-text"},[(0,s._)("code",null,"def f((a,(b,c)))\n")]),(0,s._)("div",{class:"line-numbers"},[(0,s._)("span",{class:"line-number"},"1"),(0,s._)("br")])],-1),H=(0,s._)("p",null,"This def syntax is no longer supported in Python 3.X. Instead, code this function as:",-1),Q=(0,s._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s._)("pre",{class:"language-text"},[(0,s._)("code",null,"def f(T): (a, (b, c)) = T\n")]),(0,s._)("div",{class:"line-numbers"},[(0,s._)("span",{class:"line-number"},"1"),(0,s._)("br")])],-1),Y=(0,s._)("p",null,"Tuple unpacking argument syntax is also disallowed by 3.X in lambda function argument lists. Somewhat asymmetrically, tuple unpacking assignment is still automatic in 3.X for loops targets",-1),J=(0,s._)("p",null,"By default, arguments are matched by position, from left to right, and you must pass exactly as many arguments as there are argument names in the function header.",-1),K=(0,s._)("p",null,[(0,s._)("img",{src:l,alt:"Table 18-1"})],-1),M=(0,s._)("p",null,"In a function call, arguments must appear in this order: any positional arguments or the *iterable form, followed by any keyword arguments or the **dict form. If we see *iterable and **dict as being unpacked to positional arguments and keyword arguments, the order becomes: any positional arguments, followed by any keyword arguments. In a broad sense, there are only two arguments: positional and keyword.",-1),V=(0,s._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s._)("pre",{class:"language-text"},[(0,s._)("code",null,"def foo(a,b,c,d,e,f,g):\n  print('ok')\nb=[2]\nx = {'d':4,'e':5}\ny = {'f':6}\nfoo(1,*b,3,**x,g=7,**y)  //ok\n")]),(0,s._)("div",{class:"line-numbers"},[(0,s._)("span",{class:"line-number"},"1"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"2"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"3"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"4"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"5"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"6"),(0,s._)("br")])],-1),$=(0,s._)("blockquote",null,[(0,s._)("p",null,'In a function header, we use the term "parameter" instead of "argument"')],-1),ee=(0,s._)("p",null,"In a function header, parameters must appear in this order: any normal parameter(name); followed by any default parameters (name=value); followed by the *name (or * in 3.X) form; followed by any name or name=value keyword-only arguments (in 3.X); followed by the **name form",-1),ne=(0,s._)("p",null,"We can use a * character by itself in the arguments list to indicate that a function does not accept a variable-length argument list but still expects all arguments following the * to be passed as keywords.",-1),ae=(0,s._)("p",null,[(0,s.Uk)("The "),(0,s._)("em",null,"name=value"),(0,s.Uk)(" form has two meaning:")],-1),se=(0,s._)("ul",null,[(0,s._)("li",null,"before the form *name, it's positional with default value"),(0,s._)("li",null,"after the form *name, it's keyword-only with default value")],-1),le=(0,s._)("p",null,"There can be at most one *name parameter, which collects all remaining positional arguments (including those in *iterabe). Similarly, There can be at most one **dict parameter, which collects all remaining keyword arguments (including those in **dict arguments).",-1),te=(0,s._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s._)("pre",{class:"language-text"},[(0,s._)("code",null,"def foo(a,b=3,*c,d,**e):\n    print(b,e)\nx = [3,4]\ny = {'d':5,'e':6,'f':7}\nfoo(1,2,*x,**y)   # 2 {'e': 6, 'f': 7}\n")]),(0,s._)("div",{class:"line-numbers"},[(0,s._)("span",{class:"line-number"},"1"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"2"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"3"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"4"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"5"),(0,s._)("br")])],-1),oe=(0,s._)("p",null,"The steps that Python internally carries out to match arguments before assignment can roughly be described as follows:",-1),ie=(0,s._)("ol",null,[(0,s._)("li",null,"Assign nonkeyword arguments by position."),(0,s._)("li",null,"Assign keyword arguments by matching names."),(0,s._)("li",null,"Assign extra nonkeyword arguments to *name tuple."),(0,s._)("li",null,"Assign extra keyword arguments to **name dictionary."),(0,s._)("li",null,"Assign default values to unassigned arguments in header.")],-1),re=(0,s._)("blockquote",null,[(0,s._)("p",null,[(0,s.Uk)("Note that in both function call and header, the "),(0,s._)("em",null,"name = value"),(0,s.Uk)(" form are not assignments.")])],-1),ue=(0,s._)("p",null,"The default parameters are attached to function objects, if you code a default to be a mutable object (e.g., def f(a=[])), the same, single mutable object is reused every time the function is later called—even if it is changed in place within the function.",-1),ce=(0,s._)("p",null,"Below is a tracer function example:",-1),de=(0,s._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s._)("pre",{class:"language-text"},[(0,s._)("code",null,"def tracer(func, *pargs, **kargs): # Accept arbitrary arguments\n  print('calling:', func.__name__)\n  return func(*pargs, **kargs) # Pass along arbitrary arguments\n")]),(0,s._)("div",{class:"line-numbers"},[(0,s._)("span",{class:"line-number"},"1"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"2"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"3"),(0,s._)("br")])],-1),me=(0,s._)("h2",{id:"advanced-function-topics",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#advanced-function-topics","aria-hidden":"true"},"#"),(0,s.Uk)(" Advanced Function Topics")],-1),he=(0,s._)("p",null,"In fact, recursion is not used nearly as often in Python as in more esoteric languages like Prolog or Lisp, because Python emphasizes simpler procedural statements like loops, which are usually more natural.",-1),pe=(0,s._)("p",null,"On the other hand, recursion—or equivalent explicit stack-based algorithms we’ll meet shortly—can be required to traverse arbitrarily shaped structures.",-1),be=(0,s._)("p",null,[(0,s.Uk)("Also note that standard Python limits the depth of its runtime call stack—crucial to recursive call programs—to trap infinite recursion errors. To expand it, use the "),(0,s._)("strong",null,"sys"),(0,s.Uk)(" module:")],-1),_e=(0,s._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s._)("pre",{class:"language-text"},[(0,s._)("code",null,">>> sys.getrecursionlimit() # 1000 calls deep default\n1000\n>>> sys.setrecursionlimit(10000) # Allow deeper nesting\n>>> help(sys.setrecursionlimit) # Read more about it\n")]),(0,s._)("div",{class:"line-numbers"},[(0,s._)("span",{class:"line-number"},"1"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"2"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"3"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"4"),(0,s._)("br")])],-1),fe=(0,s._)("h3",{id:"function-attributes-and-annotations",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#function-attributes-and-annotations","aria-hidden":"true"},"#"),(0,s.Uk)(" Function attributes and annotations")],-1),ge=(0,s._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s._)("pre",{class:"language-text"},[(0,s._)("code",null,">>> func.__code__\n>>> func.__code__.co_varnames\n")]),(0,s._)("div",{class:"line-numbers"},[(0,s._)("span",{class:"line-number"},"1"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"2"),(0,s._)("br")])],-1),ye=(0,s._)("p",null,"Python’s own implementation-related data stored on functions follows naming conventions that prevent them from clashing with the more arbitrary attribute names you might assign yourself. In 3.X, all function internals’ names have leading and trailing double underscores (“__X__”);",-1),xe=(0,s._)("p",null,"Attributes are related to objects instead of scopes (and must be referenced through the function name within its code).",-1),ve=(0,s._)("p",null,[(0,s.Uk)("Python provides special syntax for specifying annotations, but it doesn’t do anything with them itself; annotations are completely optional, and when present are simply attached to the function object’s "),(0,s._)("strong",null,"annotations"),(0,s.Uk)(" attribute for use by other tools. Syntactically, function annotations are coded in def header lines, as arbitrary expressions associated with arguments and return values.")],-1),ke=(0,s._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s._)("pre",{class:"language-text"},[(0,s._)("code",null,">>> def func(a: 'spam', b: (1, 10), c: float) -> int:\nreturn a + b + c\n>>> func(1, 2, 3)\n6\n>>> func.__annotations__\n{'c': <class 'float'>, 'b': (1, 10), 'a': 'spam', 'return': <class 'int'>}\n")]),(0,s._)("div",{class:"line-numbers"},[(0,s._)("span",{class:"line-number"},"1"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"2"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"3"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"4"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"5"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"6"),(0,s._)("br")])],-1),we=(0,s._)("p",null,"Finally, note that annotations work only in def statements, not lambda expressions.",-1),Ue=(0,s._)("ul",null,[(0,s._)("li",null,[(0,s._)("strong",null,"lambda"),(0,s.Uk)(" is an expression, not a statement.")]),(0,s._)("li",null,"lambda’s body is a single expression, not a block of statements."),(0,s._)("li",null,"Defaults work on lambda arguments, just like in a def."),(0,s._)("li",null,"The code in a lambda body also follows the same scope lookup rules as code inside a def. lambda expressions introduce a local scope much like a nested def, which automatically sees names in enclosing functions, the module, and the built-in scope (via the LEGB rule)")],-1),Te=(0,s._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,s._)("pre",{class:"language-text"},[(0,s._)("code",null,">>> ((lambda x: (lambda y: x + y))(99))(4)\n103\n")]),(0,s._)("div",{class:"line-numbers"},[(0,s._)("span",{class:"line-number"},"1"),(0,s._)("br"),(0,s._)("span",{class:"line-number"},"2"),(0,s._)("br")])],-1),Ae=(0,s._)("p",null,"useful library: functools, operator",-1),Xe=(0,s._)("h2",{id:"comprehensions-and-generations",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#comprehensions-and-generations","aria-hidden":"true"},"#"),(0,s.Uk)(" Comprehensions and Generations")],-1),Ie=(0,s._)("p",null,"map calls can be twice as fast as equivalent for loops, and list comprehensions are often faster than map calls.",-1),Pe=(0,s._)("p",null,"Generator function vs. Generator vs. Generator expression",-1),je=(0,s._)("ul",null,[(0,s._)("li",null,[(0,s._)("em",null,"send"),(0,s.Uk)(" advances to the next item")]),(0,s._)("li",null,[(0,s._)("em",null,"yield"),(0,s.Uk)(" is now an expression form, it must be enclose in parentheses unless it's the only item on the right ride of the assignment statement.")]),(0,s._)("li",null,[(0,s.Uk)("methods: "),(0,s._)("em",null,"throw"),(0,s.Uk)(", "),(0,s._)("em",null,"close")]),(0,s._)("li",null,[(0,s._)("em",null,"yield from")])],-1),Ge=(0,s._)("p",null,"Generator expressions may also run slightly slower than list comprehensions in practice, so they are probably best used only for very large result sets, or applications that cannot wait for full results generation.",-1),Be=(0,s._)("p",null,"A subtle but important point: both generator functions and generator expressions are their own iterators and thus support just one active iteration.",-1),Fe=(0,s._)("p",null,"Python 3.X localizes loop variables in all four forms—temporary loop variable names in generator, set, dictionary, and list comprehensions are local to the expression.",-1),qe=(0,s._)("p",null,"In general, list comprehensions are usually the quickest of the bunch; map beats list comprehensions in Python only when all tools must call functions; for loops tend to be slower than comprehensions; and generator functions and expressions are slower than comprehensions by a constant factor. Under",-1),Le=(0,s._)("h2",{id:"the-benchmarking-interlude",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#the-benchmarking-interlude","aria-hidden":"true"},"#"),(0,s.Uk)(" The benchmarking Interlude")],-1),Ne=(0,s._)("p",null,"Timeing modules: time, timer, profile, timeit, pystone.py",-1),Re={},Se=(0,a(3744).Z)(Re,[["render",function(e,n){return(0,s.wg)(),(0,s.iD)(s.HY,null,[t,o,i,r,u,c,d,m,h,p,b,_,f,g,y,x,v,k,w,U,T,A,X,I,P,j,G,B,F,q,L,N,R,S,E,z,C,D,O,W,Z,H,Q,Y,J,K,M,V,$,ee,ne,ae,se,le,te,oe,ie,re,ue,ce,de,me,he,pe,be,_e,fe,ge,ye,xe,ve,ke,we,Ue,Te,Ae,Xe,Ie,Pe,je,Ge,Be,Fe,qe,Le,Ne],64)}]])},3744:(e,n)=>{n.Z=(e,n)=>{const a=e.__vccOpts||e;for(const[e,s]of n)a[e]=s;return a}},8033:(e,n,a)=>{e.exports=a.p+"assets/img/2018-09-04-20-04-02.5ac8aa0b.png"}}]);