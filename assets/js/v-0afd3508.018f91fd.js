"use strict";(self.webpackChunkblog2=self.webpackChunkblog2||[]).push([[3499],{9902:(e,o,t)=>{t.r(o),t.d(o,{data:()=>n});const n={key:"v-0afd3508",path:"/python/notes_for_fluent_python.html",title:"",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:3,title:"Built-in Sequences",slug:"built-in-sequences",children:[]}],filePathRelative:"python/notes_for_fluent_python.md",git:{updatedTime:163774408e4,contributors:[{name:"guyong",email:"jcel@qq.com",commits:1}]}}},3198:(e,o,t)=>{t.r(o),t.d(o,{default:()=>s});const n=(0,t(6252).uE)('<p>One of the best qualities of Python is its consistency.</p><p><em>dunder method</em>: <code>__getitem__</code>, <code>__len__</code></p><p>Unless your are doing a lot of metaprogramming, you should be implementing special methods more often than invoking them directly. The only special method that is frequently called by user code directly is <code>__init__</code>, to invoke the initializer of the superclass in your own <code>__init__</code> implementation.</p><h3 id="built-in-sequences" tabindex="-1"><a class="header-anchor" href="#built-in-sequences" aria-hidden="true">#</a> Built-in Sequences</h3><ul><li>container sequences: <code>list</code>, <code>tuple</code> and <code>collections.deque</code> can hold items of different types</li><li>flat sequences: <code>str</code>, <code>bytes</code>, <code>bytearray</code>, <code>memoryview</code> and <code>array.array</code> hold items of one type</li></ul><p>Flat sequences don&#39;t contain references but physically hold their data in contiguous memory.</p><p>Another way of grouping is by mutability</p><ul><li>mutable: <code>list</code>, <code>bytearray</code>, <code>array.array</code>, <code>collections.deque</code>, and <code>memoryview</code></li><li>immutable: <code>tuple</code>, <code>str</code>, and <code>bytes</code></li></ul><p>List comprehensions (listcomps), generator expressions, and their siblings <code>set</code> and <code>dict</code> comprehensions now have their own local scope, like functions.</p><p>Listcomps build lists from sequences or any other iterable type by filtering and transforming items. Listcomps do everything the <code>map</code> and <code>filter</code> function do, without the functionally challenged Python <strong>lambda</strong>.</p><p>To initialize tuples, arrays and other types of sequences, you could also start from a listcomp, but a genexp saves memory.</p><p>Tuple unpacking works with any iterable object. The only requirement is that the iterable yields exactly one item per variable in the receiving tuple, unless you use a star(*) to capture excess items.</p><p><code>tuple</code> supports all <code>list</code> methods that do not involve adding or removing items, with one exception --- tuples lack the <code>__reversed__</code> method. However, that is just for optimization; <code>reversed(my_typle)</code> works without it.</p><p>If <code>__add__</code> is not implemented, Python falls back to call <code>__add__</code>. Consider <code>a += b</code>. If <code>a</code> implements <code>__iadd__</code>, that will be called. In the case of mutable sequences, <code>a</code> will be changed in place. However, when <code>a</code> does not implement <code>__iadd__</code>, the expression <code>a += b</code> has the same effect as <code>a = a + b</code>: the expression <code>a + b</code> is evaluated first, producing a new object, which is then bound to <code>a</code>. In other words, the identify of the object bound to <code>a</code> may or may not change, depending on the availability of <code>__iadd__</code>.</p><p>Repeated concatenation of immutable sequences is inefficient, but <code>str</code> is an exception because CPython is optimized for it by allocating spare room in memory.</p><p>An intriguing corner case:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&gt;&gt;&gt; t = (1,2,[30,40])\n&gt;&gt;&gt; t[2] += [50, 60]\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: &#39;tuple&#39; object does not support item assignment\n&gt;&gt;&gt; t\n(1, 2, [30, 40, 50, 60])\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&gt;&gt;&gt; dis.dis(&#39;s[a] += b&#39;)\n  1           0 LOAD_NAME                0 (s)\n              2 LOAD_NAME                1 (a)\n              4 DUP_TOP_TWO\n              6 BINARY_SUBSCR\n              8 LOAD_NAME                2 (b)\n             10 INPLACE_ADD\n             12 ROT_THREE\n             14 STORE_SUBSCR\n             16 LOAD_CONST               0 (None)\n             18 RETURN_VALUE\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ul><li>Putting mutable items in tuples is not a good idea.</li><li>Augmented assignment is not an atomic operation</li><li>Inspecting Python bytecode is not too difficult, and is often helpful to see what is going on under the hood.</li></ul><p>Functions or methods that change an object in place should return <code>None</code> to make it clear to the caller that the object itself was changed and no new object was created.</p><p>In contrast, the built-in function <code>sorted</code> creates a new list and return it. In fact, it accepts any iterable object as an argument, including immutable sequences and generators. Regardless of the type of iterable given to <code>sorted</code>, it always returns a newly created list.</p><p>Timsort --- the sorting algorithm used in <code>sorted</code> and <code>list.sort</code> --- is stable. It is an adaptive algorithm that switchs from insertion sort to merge sort strategies.</p><p><code>bisect.bisect</code>, <code>bisect.bisect_left</code>, <code>bisect.insort</code>, <code>bisect.insort_left</code></p><p>If you need to store 10 million floating-point values, an <code>array</code> is much more efficient than a <code>list</code>.</p><p>Beside <code>collections.deque</code>, other Python standard library packages implement queues:</p><ul><li><code>queue</code>: <code>Queue</code>, <code>LifoQueue</code>, <code>PriorityQueue</code></li><li><code>multiprocessing</code>: <code>Queue</code>, <code>JoinableQueue</code></li><li><code>asyncio</code>: <code>Queue</code>, <code>LifoQueue</code>, <code>PriorityQueue</code>, <code>JoinableQueue</code></li><li><code>heapq</code></li></ul><p><code>dict</code>, <code>defaultdict</code>, <code>OrderedDict</code>, <code>ChainMap</code>, <code>Counter</code><br> Two powerful methods: <code>setdefault</code>, <code>update</code><br><code>Mapping</code>, <code>MutableMapping</code>, <code>MappingProxyType</code></p><p>Each item in <code>bytes</code> or <code>bytearray</code> is an integer from 0 to 255, and not a one-character string. However, a slice of a binary sequence always produce a binary sequence of the same type --- including slices of length 1.</p><p>The only sequence type where <code>s[0] == s[:1]</code> is the <code>str</code> type.</p><p>Three different displays are used, depending on each byte value. Both <code>bytes</code> and <code>bytearray</code> support every <code>str</code> method except those that do formating and a few others that depend on Unicode data.</p><p><code>memoryview</code>, <code>struct</code>, <code>mmap</code></p><p>character encoding detecting: <code>Chardet</code>, <code>chardetect</code></p><p>endianness: BOM</p><p>In Python 3, <code>map</code> and <code>filter</code> return generators --- a form of iterator --- so their direct substitute is now a generator expression.</p><p>A class implementing <code>__call__</code> is an easy way to creat funciton-like objects that have some internal state that must be kept acrosss invocations. A totally different approach to creating functions with internal state is to use closures.</p><p>Retriving information about parameters: <code>inspect</code> module</p><p>The <code>operator</code> module: <code>itemgetter</code>, <code>attrgetter</code>, <code>methodcaller</code><br> The <code>functools</code> module: <code>partial</code>, <code>partialmethod</code></p><p>Decorators: <code>property</code>, <code>classmethod</code>, <code>staticmethod</code>, <code>functools.wraps</code>, <code>functools.lru_cache</code>, <code>functools.singledispatch</code></p><p>lexical scope vs. dynamic scope</p><blockquote><p>To understand an assignment in Python, always read the right-hand side first: that&#39;s where the object is created or retrived. After that, the variable on the left is bound to the object, like a label stuck to it. Just forget about boxes.</p></blockquote><p>Every object has an identity, a type and a value. An object&#39;s identity never changes once it has been created (only the value of an object changes over time); you may think of it as the object&#39;s adress in memory. The <code>is</code> operator compares the identity of two objects; the <code>id()</code> fucntion returns an integer representing its identity.</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a <span class="token operator">=</span> <span class="token boolean">None</span>\n<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> b <span class="token operator">=</span> <span class="token boolean">None</span>\n<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a <span class="token operator">==</span> b\n<span class="token boolean">True</span>\n<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a <span class="token keyword">is</span> b <span class="token comment"># faster than ==</span>\n<span class="token boolean">True</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>The easiest way to copy a list (or most built-in mutable collections) is to use the built-in constructor for the type itself. However, using the constructor or <code>[:]</code> produces a <em>shallow copy</em>.</p><p><code>copy.copy()</code>, <code>copy.deepcopy()</code><br> Note that making deep copy is not a simple matter in the general case. Objects have cyclic references that would cause a naive algorithm to enter an infinite loop. The <code>deepcopy</code> function remembers the objects already copied to handle cyclic references gracefully.</p><p>Mutable types as parameter defaults: bad idea</p><p>default argument is evaluated only once at the point of function definition in the defining scope.</p><p>The issue with mutable defaults explains why <code>None</code> is often used as the default value for parameters that may receive mutable values.</p><p>The <code>del</code> statement deletes names, not objects.</p><p><code>weakref</code></p><p>Consider using <code>WeakKeyDictionary</code>, <code>WeakValueDictionary</code>, <code>WeakSet</code> and <code>finalize</code>(which use weak references internally) instead of creating and handling your own <code>weakref.ref</code> instances by hand.</p><p>If you need to build a class that is aware of every one of its instances, a good solution is to create a class attribute with a <code>WeakSet</code> to hold the references to the instances.</p><p>Not every Python object may be the target, or referent, of a weak reference. Basid <code>list</code> and <code>dict</code> instances may not be referents, but a plain subclass of either can solve this problem easily. Most of these limitations are implementation details of CPython that may not apply to other Python interpreters.</p><p>CPython may cheat when copying:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> t1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>\n<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> t2 <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span>\n<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> t2 <span class="token keyword">is</span> t1\n<span class="token boolean">True</span>\n<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> t3 <span class="token operator">=</span> t1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>\n<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> t3 <span class="token keyword">is</span> t1\n<span class="token boolean">True</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>string interning</p><p>Instances of user-defined classes are mutable by default in Python -- as in most object-oriented languages. When creating your own objects, you have to be extra careful to make them immutable, if that is a requirement.</p>',56),a={},s=(0,t(3744).Z)(a,[["render",function(e,o){return n}]])},3744:(e,o)=>{o.Z=(e,o)=>{const t=e.__vccOpts||e;for(const[e,n]of o)t[e]=n;return t}}}]);