"use strict";(self.webpackChunkblog2=self.webpackChunkblog2||[]).push([[5299],{4487:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-5aa35a18",path:"/python/python-async.html",title:"",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"Future",slug:"future",children:[]},{level:2,title:"Select",slug:"select",children:[]},{level:2,title:"asyncio",slug:"asyncio",children:[]},{level:2,title:"Coroutine",slug:"coroutine",children:[]},{level:2,title:"Task",slug:"task",children:[]},{level:2,title:"Event_loop",slug:"event-loop",children:[]}],filePathRelative:"python/python-async.md",git:{updatedTime:163774408e4,contributors:[{name:"guyong",email:"jcel@qq.com",commits:1}]}}},8217:(n,s,a)=>{a.r(s),a.d(s,{default:()=>u});var e=a(6252);const t=(0,e.uE)('<h2 id="future" tabindex="-1"><a class="header-anchor" href="#future" aria-hidden="true">#</a> Future</h2><p>python 中的 Future 相当于 js 中的 Promise ，功能是把”事件发生“ 与”回调函数“ 分离。不仅可以先注册callback, 等“事件发生”（Future中是set_result, js中是resolve)后自动调用一个或多个callback; 还可以在 set_result后在注册callback. 内部通过保存”事件发生“这一状态来实现 Deferred 效果。</p><h2 id="select" tabindex="-1"><a class="header-anchor" href="#select" aria-hidden="true">#</a> Select</h2><p>python中的select module中有针对不同平台的系统函数来完成IO复用的功能，最原始的是select函数, 在大多数平台上都有。poll比 select更优化一些，本质上差不多。只存在于linux上的epoll 以及 BSD 上的 kqueue，windows上的IOCP, Solaris上的devpoll 则更加优化和强大。其中IOCP是真正的异步，不存在阻塞，其它或多或少有一点阻塞，epoll和kqueue在性能上基本上更真正的异步差不多，devpoll不太清楚。</p><p>这些类select函数根据平台的不同，有的只支持sockets（IOCP), 有的还支持pipe( epoll ) 或其它file-like objects. 有的只能监听到readable/writable/error, 有的能精确区分更复杂的事件。epoll 有水平（level）触发和边沿（edge)触发。</p><p>python中的selectors module (相当于nodejs中隐含在内部的libuv库） 则将这些不同的select函数抽象成一个统一的接口，用户只需要用DefaultSelector 来获得当前平台下最适合的select。这些类select主要实现以下功能</p><p>register(fileobj, events, data=Non): 注册fileobj 以及需要监听的事件</p><p>unregister(fileobj): 注销</p><p>modify(fileobj, events, data=Non): 更改</p><p>select(timeout=None): 返回有”事件发生“的(key, events) list, 其中的key 为SectorKey类，包含fileobj, fd, events, data。该方法会根据timeout的值进行阻塞或非阻塞调用。其内部原理比较复杂，大致是结合了中断和轮询来实现的。</p>',10),p={href:"https://blog.csdn.net/hdutigerkin/article/details/7517390",target:"_blank",rel:"noopener noreferrer"},o=(0,e.Uk)("epoll详细工作原理"),l=(0,e.uE)('<h2 id="asyncio" tabindex="-1"><a class="header-anchor" href="#asyncio" aria-hidden="true">#</a> asyncio</h2><p>有了python的callback机制，以及select module, 我们已经可以手写地实现python中的异步功能。但是，这样写会很麻烦，代码不易读。于是就有了各种第三方库来简化，如 Tornado, Twisted, Gevent, Eventlet, greenlet等。从3.4开始, python引入了标准库 asyncio.</p><p>greenlet （比较低级，一般用来构建其它库） Eventlet (基于IO复用和coroutine, 相当于implictly调用coroutine, 不需要像coroutine那样explictly切换控制流) Gevent (与Eventlet类似，但功能更强大） Twisted（面向对象，基于事件驱动的网络库，比较低级） Tornado (作为一个web框架和异步网络库使用，同样基于IO复用和coroutine） async实现了许多功能，要理解它的话需要理解以下几个关键的东西：coroutine, Task, event_loop</p><h2 id="coroutine" tabindex="-1"><a class="header-anchor" href="#coroutine" aria-hidden="true">#</a> Coroutine</h2><p>coroutine是通过将Future与generator结合实现的, 其核心在于：</p><p>通过yield一个Future将该运行中的coroutine控制流”挂起“ ，相当于thread中的sleep。然而这里是通过generator的机制来保存其运行中间状态，而不是thread中的context switch. 这样不仅比thread节省时间和空间资源，还能减少绝大多数的data race. 因为这里的控制流只在yield处才会被挂起，而thread的挂起是由内核决定的，可发生的任意时候（除非加锁，disable中断）。因些coroutne某种意义上可看作green thread(轻量级线程） 在需要的时候（例如Task中），通过send将某个coroutine唤醒 coroutine 的好处在于可以将异步流用同步的方式来写。</p><h2 id="task" tabindex="-1"><a class="header-anchor" href="#task" aria-hidden="true">#</a> Task</h2><p>以下是Task的一个简化版</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Task</span><span class="token punctuation">:</span>\n  <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> coro<span class="token punctuation">)</span><span class="token punctuation">:</span>\n  self<span class="token punctuation">.</span>coro <span class="token operator">=</span> coro\n  f <span class="token operator">=</span> Future<span class="token punctuation">(</span><span class="token punctuation">)</span>\n  f<span class="token punctuation">.</span>set_result<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>\n  self<span class="token punctuation">.</span>step<span class="token punctuation">(</span>f<span class="token punctuation">)</span>\n\n  <span class="token keyword">def</span> <span class="token function">step</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> future<span class="token punctuation">)</span><span class="token punctuation">:</span>\n  <span class="token keyword">try</span><span class="token punctuation">:</span>\n  next_future <span class="token operator">=</span> self<span class="token punctuation">.</span>coro<span class="token punctuation">.</span>send<span class="token punctuation">(</span>future<span class="token punctuation">.</span>result<span class="token punctuation">)</span>\n  <span class="token keyword">except</span> StopIteration<span class="token punctuation">:</span>\n  <span class="token keyword">return</span>\n\n  next_future<span class="token punctuation">.</span>add_done_callback<span class="token punctuation">(</span>self<span class="token punctuation">.</span>step<span class="token punctuation">)</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>每构造一个Task, 其中的coroutine就会执行，一直到yield处”挂起“，并返回一个Future。等到Future被set_result后，该coroutine又会被”唤醒“。其中Future的set_result是由select来完成的。</p><h2 id="event-loop" tabindex="-1"><a class="header-anchor" href="#event-loop" aria-hidden="true">#</a> Event_loop</h2><p>run_until_complete函数接收一个或多个Task对象（若是Future的话，会自动包装生成Task)，直至所有的Task返回。这些Task的”用户代码“ 可以看作是运行在单线程中，而IO操作是通过select功能得到复用。</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">EventLoop</span><span class="token punctuation">:</span>\n    <span class="token keyword">def</span> <span class="token function">run_until_complete</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> coro<span class="token punctuation">)</span><span class="token punctuation">:</span>\n        <span class="token triple-quoted-string string">&quot;&quot;&quot;Run until the coroutine is done.&quot;&quot;&quot;</span>\n        task <span class="token operator">=</span> Task<span class="token punctuation">(</span>coro<span class="token punctuation">)</span>\n        task<span class="token punctuation">.</span>add_done_callback<span class="token punctuation">(</span>stop_callback<span class="token punctuation">)</span>\n        <span class="token keyword">try</span><span class="token punctuation">:</span>\n            self<span class="token punctuation">.</span>run_forever<span class="token punctuation">(</span><span class="token punctuation">)</span>\n        <span class="token keyword">except</span> StopError<span class="token punctuation">:</span>\n            <span class="token keyword">pass</span>\n\n<span class="token keyword">class</span> <span class="token class-name">StopError</span><span class="token punctuation">(</span>BaseException<span class="token punctuation">)</span><span class="token punctuation">:</span>\n    <span class="token triple-quoted-string string">&quot;&quot;&quot;Raised to stop the event loop.&quot;&quot;&quot;</span>\n\n<span class="token keyword">def</span> <span class="token function">stop_callback</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">:</span>\n    <span class="token keyword">raise</span> StopError\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>有了coroutine, Task, Event_loop 后，我们还需要自己写select的注册/注销/返回事件 等操作，register写在yield前，unregister写在yield后。但是一些支持异步的库会自动实现这两步，不需要手动来写。例如aiohttp.</p><p>selector.select()函数的调用也不需要手写，个人猜测是event_loop自动开了这样一个coroutine (或thread)运行。</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>\n    events <span class="token operator">=</span> selector<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token keyword">for</span> event_key<span class="token punctuation">,</span> event_mask <span class="token keyword">in</span> events<span class="token punctuation">:</span>\n        callback <span class="token operator">=</span> event_key<span class="token punctuation">.</span>data\n        callback<span class="token punctuation">(</span>event_key<span class="token punctuation">,</span> event_mask<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div>',16),c={},u=(0,a(3744).Z)(c,[["render",function(n,s){const a=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.iD)(e.HY,null,[t,(0,e._)("p",null,[(0,e._)("a",p,[o,(0,e.Wm)(a)])]),l],64)}]])},3744:(n,s)=>{s.Z=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}}}]);