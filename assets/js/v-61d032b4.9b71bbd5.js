"use strict";(self.webpackChunkblog2=self.webpackChunkblog2||[]).push([[6944],{8393:(e,t,o)=>{o.r(t),o.d(t,{data:()=>a});const a={key:"v-61d032b4",path:"/python/notes_for_learning_python/5_Modules-and-Packages.html",title:"Part V. Modules and Packages",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:3,title:"The Module Search Path",slug:"the-module-search-path",children:[]},{level:2,title:"Module Coding Basics",slug:"module-coding-basics",children:[{level:3,title:"Module Filenames",slug:"module-filenames",children:[]},{level:3,title:"Reloading Modules",slug:"reloading-modules",children:[]}]},{level:2,title:"Module Packages",slug:"module-packages",children:[]}],filePathRelative:"python/notes_for_learning_python/5_Modules-and-Packages.md",git:{updatedTime:163774408e4,contributors:[{name:"guyong",email:"jcel@qq.com",commits:1}]}}},1803:(e,t,o)=>{o.r(t),o.d(t,{default:()=>i});const a=(0,o(6252).uE)('<h1 id="part-v-modules-and-packages" tabindex="-1"><a class="header-anchor" href="#part-v-modules-and-packages" aria-hidden="true">#</a> Part V. Modules and Packages</h1><p>Modules are processed with two statements and one important function:</p><ul><li>import: Lets a client (importer) fetch a module as a whole</li><li>from: Allows clients to fetch particular names from a module</li><li>imp.reload (reload in 2.X): Provides a way to reload a module’s code without stopping Python</li></ul><p>In Python, cross-file module linking is not resolved until such import statements are executed at runtime; their net effect is to assign module names—simple variables like b—to loaded module objects. In fact, the module name used in an import statement serves two purposes: it identifies the external file to be loaded, but it also becomes a variable assigned to the loaded module.</p><p>Similarly, objects defined by a module are also created at runtime, as the import is executing: import literally runs statements in the target file one at a time to create its contents.</p><p>In python, imports perform three distinct steps the first time a program imports a given file:</p><ol><li>Find the module’s file.</li><li>Compile it to byte code (if needed).</li><li>Run the module’s code to build the objects it defines.</li></ol><p>Bear in mind that all three of these steps are carried out only the first time a module is imported during a program’s execution; later imports of the same module in a program run bypass all of these steps and simply fetch the already loaded module object in memory. Technically, Python does this by storing loaded modules in a table named <strong>sys.mod</strong> ules and checking there at the start of an import operation. If the module is not present, a three-step process begins. (see <strong>imp.reload</strong>)</p><blockquote><p>Python keeps already imported modules in the built-in <strong>sys.modules</strong> dictionary so it can keep track of what’s been loaded.</p></blockquote><p>Notice that compilation happens when a file is being imported. Because of this, you will not usually see a .pyc byte code file for the top-level file of your program, unless it is also imported elsewhere—only imported files leave behind .pyc files on your machine.</p><h3 id="the-module-search-path" tabindex="-1"><a class="header-anchor" href="#the-module-search-path" aria-hidden="true">#</a> The Module Search Path</h3><p>Roughly, Python’s module search path is composed of the concatenation of these major components, some of which are preset for you and some of which you can tailor to tell Python where to look:</p><ol><li>The home directory of the program (subdirectories not included)</li><li>PYTHONPATH directories (if set)</li><li>Standard library directories</li><li>The contents of any .pth files (if present)</li><li>The site-packages home of third-party extensions</li></ol><p>Ultimately, the concatenation of these four components becomes <strong>sys.path</strong>, a mutable list of directory. The first and third elements of the search path are defined automatically. Because Python searches the concatenation of these components from first to last, though, the second and fourth elements can be used to extend the path to include your own source code directories.</p><p>By modifying the sys.path list, you can modify the search path for all future imports made in a program’s run. Such changes last only for the duration of the script, however; PYTHONPATH and .pth files offer more permanent ways to modify the path—the first per user, and the second per installation.</p><p>Python automatically selects any type that matches a module’s name. For same names with different extensions, Python follows a standard picking order, though this order is not guaranteed to stay the same over time or across implementations.</p><p>By using import hooks, archived files are automatically extracted at import time when a .zip file is selected from the module import search path.</p><p>For details, see the builtin <strong>importlib.__import__</strong> function</p><p>Third-party extensions for Python typically use the <strong>distutils</strong> tools in the standard library to automatically install themselves, so no path configuration is required to use their code.</p><p>Systems that use distutils generally come with a setup.py script, which is run to install them; this script imports and uses distutils modules to place such systems in a directory that is automatically part of the module search path (usually in the Lib\\site-packages subdirectory of the Python install tree, wherever that resides on the target machine).</p><h2 id="module-coding-basics" tabindex="-1"><a class="header-anchor" href="#module-coding-basics" aria-hidden="true">#</a> Module Coding Basics</h2><h3 id="module-filenames" tabindex="-1"><a class="header-anchor" href="#module-filenames" aria-hidden="true">#</a> Module Filenames</h3><p>The .py is technically optional for top-level files that will be run but not imported.</p><p>In fact, both the names of module files and the names of directories used in package imports (discussed in the next chapter) must conform to the rules for variable names presented.</p><p><strong>import</strong> fetches the module as a whole, so you must qualify to fetch its names; in contrast, <strong>from</strong> fetches (or copies) specific names out of the module.</p><p>In Python 3.X, the from ...* statement form described here can be used only at the top level of a module file, not within a function.</p><p>Just like def, import and from are executable statements, not compile-time declarations. They may be nested in if tests, to select among options; appear in function defs, to be loaded only on calls (subject to the preceding note); be used in try statements, to provide defaults; and so on.</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&gt;&gt;&gt; from small import x, y # Copy two names out\n&gt;&gt;&gt; x = 42 # Changes local x only\n&gt;&gt;&gt; y[0] = 42 # Changes shared mutable in place\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>At least conceptually, a from statement like this one:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>from module import name1, name2 # Copy these two names out (only)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>is equivalent to this statement sequence:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import module # Fetch the module object\nname1 = module.name1 # Copy names out by assignment\nname2 = module.name2\ndel module # Get rid of the module name\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>The <strong>from</strong> always imports the entire module into memory if it has not yet been imported, regardless of how many names it copies out of the file. There is no way to load just part of a module file.</p><p>Moreover, the from module import * form really can corrupt namespaces and make names difficult to understand, especially when applied to more than one file.</p><p>Probably the best real-world advice here is to generally prefer import to from for simple modules, to explicitly list the variables you want in most from statements, and to limit the from * form to just one import per file.</p><p>The <strong>as</strong> extension works in both import and from as a simple renaming tool.</p><p>In fact, internally, module namespaces are stored as dictionary objects.</p><p>The LEGB scope rule applies only to bare, unqualified names—it may be used for the leftmost name in a name path, but later names after dots search specific objects instead.</p><p>lexical scoping notion—in Python, the scopes surrounding a piece of code are completely determined by the code’s physical position in your file. Scopes are never influenced by function calls or module imports.</p><p>import operations never give upward visibility to code in imported files —an imported file cannot see names in the importing file. In some sense, although imports do not nest namespaces upward, they do nest downward.</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>print(mod2.mod3.X) # Nested mod3&#39;s X\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="reloading-modules" tabindex="-1"><a class="header-anchor" href="#reloading-modules" aria-hidden="true">#</a> Reloading Modules</h3><p>The <strong>reload</strong> function forces an already loaded module’s code to be reloaded and rerun. Assignments in the file’s new code change the existing module object in place.</p><blockquote><p>Note that reload currently only works on modules written in Python;</p></blockquote><p>Because reload expects an object, a module must have been previously imported successfully before you can reload it.</p><p>When you call reload, Python rereads the module file’s source code and reruns its toplevel statements. Perhaps the most important thing to know about reload is that it changes a module object in place; it does not delete and re-create the module object.</p><ul><li>Reloads impact all clients that use <strong>import</strong> to fetch modules</li><li>Reloads impact future from clients only. Clients that used from to fetch attributes in the past won’t be affected by a reload; they’ll still have references to the old objects fetched before the reload.</li><li>Reloads apply to a single module only. You must run them on each module you wish to update, unless you use code or tools that apply reloads transitively.</li></ul><h2 id="module-packages" tabindex="-1"><a class="header-anchor" href="#module-packages" aria-hidden="true">#</a> Module Packages</h2><p>Dotted package<br><strong>from package import item</strong>: the item can be either a submodule (or subpackage) of the package, or some other name defined in the package, like a function, class or variable.<br><strong>import item.subitem.subitem</strong>: each item except for the last must be a package; the last item can be a module or a package but can&#39;t be a class or function or variable defined in the previous item.</p><p>Tow kinds of imports:</p><ul><li>absolute imports</li><li>relative imports</li></ul><p>In sum, Python imports select between relative (in the containing directory) and absolute (in a directory on sys.path) resolutions as follows:</p><ul><li>Dotted imports: from . import m<br> Are relative-only in both 2.X and 3.X</li><li>Nondotted imports: import m, from m import x<br> Are relative-then-absolute in 2.X, and absolute-only in 3.X</li></ul><p>Note that relative imports are based on the name of the current module. Since the name of the main module is always &quot;<strong>main</strong>&quot;, modules intended for use as the main module of a Python application must always use absolute imports.</p><p>Python 3.3 adds another flavor to modules: <em>namespace packages</em>.</p><p>Packages are just a special kind of module. Specifically, any module that contains a <code>__path__</code> attribute is considered a package.</p><p>Two kinds of packages:</p><ul><li>regular packages</li><li>namespace packages</li></ul>',58),s={},i=(0,o(3744).Z)(s,[["render",function(e,t){return a}]])},3744:(e,t)=>{t.Z=(e,t)=>{const o=e.__vccOpts||e;for(const[e,a]of t)o[e]=a;return o}}}]);