"use strict";(self.webpackChunkblog2=self.webpackChunkblog2||[]).push([[2418],{7312:(e,t,n)=>{n.r(t),n.d(t,{data:()=>i});const i={key:"v-bcfdfc88",path:"/dev/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6.html",title:"",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"线程基础知识",slug:"线程基础知识",children:[]},{level:2,title:"互斥锁Mutex",slug:"互斥锁mutex",children:[]},{level:2,title:"Condition Variables",slug:"condition-variables",children:[]},{level:2,title:"Semaphore 信号量",slug:"semaphore-信号量",children:[]},{level:2,title:"Python中的Event, Queue",slug:"python中的event-queue",children:[]},{level:2,title:"References",slug:"references",children:[]}],filePathRelative:"dev/线程同步机制.md",git:{updatedTime:163774408e4,contributors:[{name:"guyong",email:"jcel@qq.com",commits:1}]}}},2798:(e,t,n)=>{n.r(t),n.d(t,{default:()=>v});var i=n(6252);const l=(0,i.uE)('<h2 id="线程基础知识" tabindex="-1"><a class="header-anchor" href="#线程基础知识" aria-hidden="true">#</a> 线程基础知识</h2><p>线程同步的底层支持包括：</p><ol><li>TSL （或其它）原子操作</li><li>中断服务</li></ol><h2 id="互斥锁mutex" tabindex="-1"><a class="header-anchor" href="#互斥锁mutex" aria-hidden="true">#</a> 互斥锁Mutex</h2><p>最基本的同步机制是锁（Lock），包括 互斥锁(Mutex), Read-Write 锁, 空转锁。以Mutex为例：</p><ul><li>对Mutex状态的判断及修改是通过机器提供的原子性指令完成的。</li><li>每个Mutex上有一个等待队列（waiting list)</li><li>Lock()操作在”locked” 情况下会被挂起，实际上是先空转（spin）一小会再挡土挂起（yield），当前线程会加入到Mutex的waiting list中。</li><li>挂起是指将线程置于”睡眠“状态，并调用线程调试函数切换到其它线程</li><li>Unlock() 操作会释放锁, 并且唤醒waiting list中的一个（或所有）线程。</li></ul><h2 id="condition-variables" tabindex="-1"><a class="header-anchor" href="#condition-variables" aria-hidden="true">#</a> Condition Variables</h2><p>pthread_join()解决的是多个线程等待同一个线程的结束。Condition variable解决的是多个线程等待某个条件发生。</p><ul><li>Condition主要用来实现通知/同步机制，内部也是由waiting list实现。实际上Mutex也有”通知唤醒“功能，但Mutex功能过于简单，用来实现通知/同步功能时容易出问题：每个线程需要不断的试图获取Mutex锁并检查条件是否发生，从而浪费大量资源。（python的condition内部就是用多个waiter lock实现的。）</li><li>Condition 一定要配合 Mutex 才能使用，因为状态的检测/改变与等待/发信操作需要具有原子性。</li><li>wait() 会自动释放Mutex, 等到被唤醒时会自动去获取Mutex</li><li>notify() 会唤唤醒waiting list中的线程</li><li>检测条件状态要用while, 发信号要在临界区</li></ul><h2 id="semaphore-信号量" tabindex="-1"><a class="header-anchor" href="#semaphore-信号量" aria-hidden="true">#</a> Semaphore 信号量</h2><p>semaphore是进程间PV，可以理解为带计数器的Condition variable</p><h2 id="python中的event-queue" tabindex="-1"><a class="header-anchor" href="#python中的event-queue" aria-hidden="true">#</a> Python中的Event, Queue</h2><h2 id="references" tabindex="-1"><a class="header-anchor" href="#references" aria-hidden="true">#</a> References</h2>',13),r={href:"http://blog.csdn.net/goondrift/article/details/19044361",target:"_blank",rel:"noopener noreferrer"},a=(0,i.Uk)("操作系统如何实现mutex"),o={href:"https://casatwy.com/pthreadde-ge-chong-tong-bu-ji-zhi.html",target:"_blank",rel:"noopener noreferrer"},h=(0,i.Uk)("pthread的各种同步机制"),s={href:"https://stackoverflow.com/questions/12551341/when-is-a-condition-variable-needed-isnt-a-mutex-enough",target:"_blank",rel:"noopener noreferrer"},d=(0,i.Uk)("When is a condition variable needed, isn't a mutex enough?"),u={href:"http://www.laurentluce.com/posts/python-threads-synchronization-locks-rlocks-semaphores-conditions-events-and-queues/",target:"_blank",rel:"noopener noreferrer"},c=(0,i.Uk)("Python threads synchronization: Locks, RLocks, Semaphores,Conditions, Events and Queues"),p={href:"http://www.cnblogs.com/Dahaka/archive/2012/02/19/2358528.html",target:"_blank",rel:"noopener noreferrer"},m=(0,i.Uk)("关于Condition Variable为什么需要一个Mutex的思考"),f={href:"https://www.cnblogs.com/vamei/archive/2012/10/09/2715393.html",target:"_blank",rel:"noopener noreferrer"},b=(0,i.Uk)("Linux并发与同步"),g={},v=(0,n(3744).Z)(g,[["render",function(e,t){const n=(0,i.up)("OutboundLink");return(0,i.wg)(),(0,i.iD)(i.HY,null,[l,(0,i._)("ul",null,[(0,i._)("li",null,[(0,i._)("a",r,[a,(0,i.Wm)(n)])]),(0,i._)("li",null,[(0,i._)("a",o,[h,(0,i.Wm)(n)])]),(0,i._)("li",null,[(0,i._)("a",s,[d,(0,i.Wm)(n)])]),(0,i._)("li",null,[(0,i._)("a",u,[c,(0,i.Wm)(n)])]),(0,i._)("li",null,[(0,i._)("a",p,[m,(0,i.Wm)(n)])]),(0,i._)("li",null,[(0,i._)("a",f,[b,(0,i.Wm)(n)])])])],64)}]])},3744:(e,t)=>{t.Z=(e,t)=>{const n=e.__vccOpts||e;for(const[e,i]of t)n[e]=i;return n}}}]);