"use strict";(self.webpackChunkblog2=self.webpackChunkblog2||[]).push([[4661],{1006:(t,e,n)=>{n.r(e),n.d(e,{data:()=>i});const i={key:"v-48cc2ad7",path:"/algorithm/union_find.html",title:"Disjoint Set Data Structure: Union-Find",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"The problem",slug:"the-problem",children:[]},{level:2,title:"Linked-list",slug:"linked-list",children:[{level:3,title:"a weighted-union heuristic",slug:"a-weighted-union-heuristic",children:[]}]},{level:2,title:"Forest",slug:"forest",children:[]}],filePathRelative:"algorithm/union_find.md",git:{updatedTime:163774408e4,contributors:[{name:"guyong",email:"jcel@qq.com",commits:1}]}}},1638:(t,e,n)=>{n.r(e),n.d(e,{default:()=>r});const i=(0,n(6252).uE)('<h1 id="disjoint-set-data-structure-union-find" tabindex="-1"><a class="header-anchor" href="#disjoint-set-data-structure-union-find" aria-hidden="true">#</a> Disjoint Set Data Structure: Union-Find</h1><h2 id="the-problem" tabindex="-1"><a class="header-anchor" href="#the-problem" aria-hidden="true">#</a> The problem</h2><p>We want to maintain a set of disjoint sets, in which elements are fixed. Only union is supported, while spliting is not. Sepcifically, we support following three operations.</p><ul><li>MakeSet(u)</li><li>Find(u)</li><li>Union(u,v)</li></ul><p>Let $V$ donote the fixed set of elements, whose size is $n$. Generally, we want to estimate the total time of a sequence of $m$ operations, in which the first $n$ operation is <strong>MakeSet</strong> for each element.</p><h2 id="linked-list" tabindex="-1"><a class="header-anchor" href="#linked-list" aria-hidden="true">#</a> Linked-list</h2><p>We can represent each set by a linked list, with each element additionally pointing to its head. The worst-case time for <strong>Union</strong> is $O(n)$, and we can find a sequence of $m$ operations which needs $O(n^2)$ time in total.</p><h3 id="a-weighted-union-heuristic" tabindex="-1"><a class="header-anchor" href="#a-weighted-union-heuristic" aria-hidden="true">#</a> a weighted-union heuristic</h3><p>We can improve it by a little trick. In the <strong>Union</strong> operation, we can rename the small set (say B) to the larger set (say A), i.e. make all the elements of B point to the head of A. The worst-case time of <strong>Union</strong> is stilll $O(n)$, while its amortized time becomes $O(\\log n)$.</p><table><thead><tr><th></th><th style="text-align:center;">worst-case</th><th style="text-align:center;">amortized</th></tr></thead><tbody><tr><td>MakeSet</td><td style="text-align:center;">$O(1)$</td><td style="text-align:center;">$O(1)$</td></tr><tr><td>Find</td><td style="text-align:center;">$O(1)$</td><td style="text-align:center;">$O(1)$</td></tr><tr><td>Union</td><td style="text-align:center;">$O(n)$</td><td style="text-align:center;">$O(\\log n)$</td></tr><tr><td>Total</td><td style="text-align:center;">$O(m\\log n)$</td><td style="text-align:center;">-</td></tr></tbody></table><h2 id="forest" tabindex="-1"><a class="header-anchor" href="#forest" aria-hidden="true">#</a> Forest</h2><p>Wite rooted trees, <strong>Union</strong> costs $O(1)$, while <strong>Find</strong> may cost <strong>O(n)</strong> in worst-case. It can also be improved to $O(\\log n)$ using the same weighted-union heuristic: Union-by-rank. Actually, Union-by-size works as well. The total time is also $O(m\\log n)$ Using another heuristic &quot;path compression&quot;, we can amortize the time of <strong>Find</strong> and <strong>Union</strong> to $O(\\alpha(n))$, which results $O(m\\alpha(n))$ time in total.</p><table><thead><tr><th></th><th style="text-align:center;">no heuristic</th><th style="text-align:center;">weighted-union</th><th style="text-align:center;">both(amortized)</th></tr></thead><tbody><tr><td>MakeSet</td><td style="text-align:center;">$O(1)$</td><td style="text-align:center;">$O(1)$</td><td style="text-align:center;">$O(1)$</td></tr><tr><td>Find</td><td style="text-align:center;">$O(n)$</td><td style="text-align:center;">$O(\\log n)$</td><td style="text-align:center;">$O(\\alpha(n))$</td></tr><tr><td>Union</td><td style="text-align:center;">$O(1)$</td><td style="text-align:center;">$O(1)$</td><td style="text-align:center;">$O(\\alpha(n))$</td></tr><tr><td>Total</td><td style="text-align:center;">$O(mn)$</td><td style="text-align:center;">$O(m\\log n)$</td><td style="text-align:center;">$O(m\\alpha(n))$</td></tr></tbody></table>',13),a={},r=(0,n(3744).Z)(a,[["render",function(t,e){return i}]])},3744:(t,e)=>{e.Z=(t,e)=>{const n=t.__vccOpts||t;for(const[t,i]of e)n[t]=i;return n}}}]);